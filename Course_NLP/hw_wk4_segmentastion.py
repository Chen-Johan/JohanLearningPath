#词典；每个词后方存储的是其词频，词频仅为示例，不会用到，也可自行修改
Dict = {"经常":0.1,
        "经":0.05,
        "有":0.1,
        "常":0.001,
        "有意见":0.1,
        "歧":0.001,
        "意见":0.2,
        "分歧":0.2,
        "见":0.05,
        "意":0.05,
        "见分歧":0.05,
        "分":0.1}

#待切分文本
sentence = "经常有意见分歧"

#实现全切分函数，输出根据字典能够切分出的所有的切分方式
def all_cut(sentence, Dict):
    target = []
    
   # 使用二叉树， DFS 深度优先搜索
    def dfs(index, path):
        # 当index到达句子末尾时，说明当前路径path是其中一种完整的切分方式
        if index == len(sentence):
            target.append(path[:])
            return
        # 将sentence按二叉树方式思考，试图从当前位置分割出一个词(左分支)或继续向后扩展(右分支)
        for i in range(index + 1, len(sentence) + 1):   # i 为分割点 ；range()函数包含左边界，不包含右边界
            seg = sentence[index:i]
            if seg in Dict:
                # 节点有效时加入path，开启下一个子问题的递归(子树)
                path.append(seg)
                dfs(i, path)
                # 回溯：撤销最后一次加入的词，方便尝试其他切分
                path.pop()

    dfs(0, [])
    return print(target)



#目标输出;顺序不重要
target = [
    ['经常', '有意见', '分歧'],
    ['经常', '有意见', '分', '歧'],
    ['经常', '有', '意见', '分歧'],
    ['经常', '有', '意见', '分', '歧'],
    ['经常', '有', '意', '见分歧'],
    ['经常', '有', '意', '见', '分歧'],
    ['经常', '有', '意', '见', '分', '歧'],
    ['经', '常', '有意见', '分歧'],
    ['经', '常', '有意见', '分', '歧'],
    ['经', '常', '有', '意见', '分歧'],
    ['经', '常', '有', '意见', '分', '歧'],
    ['经', '常', '有', '意', '见分歧'],
    ['经', '常', '有', '意', '见', '分歧'],
    ['经', '常', '有', '意', '见', '分', '歧']
]


if __name__ == "__main__":
    all_cut(sentence, Dict)
    


